// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_ref_image_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddRefImageState {}

/// @nodoc
abstract class $AddRefImageStateCopyWith<$Res> {
  factory $AddRefImageStateCopyWith(
          AddRefImageState value, $Res Function(AddRefImageState) then) =
      _$AddRefImageStateCopyWithImpl<$Res, AddRefImageState>;
}

/// @nodoc
class _$AddRefImageStateCopyWithImpl<$Res, $Val extends AddRefImageState>
    implements $AddRefImageStateCopyWith<$Res> {
  _$AddRefImageStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AddRefImageStateInitialImplCopyWith<$Res> {
  factory _$$AddRefImageStateInitialImplCopyWith(
          _$AddRefImageStateInitialImpl value,
          $Res Function(_$AddRefImageStateInitialImpl) then) =
      __$$AddRefImageStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddRefImageStateInitialImplCopyWithImpl<$Res>
    extends _$AddRefImageStateCopyWithImpl<$Res, _$AddRefImageStateInitialImpl>
    implements _$$AddRefImageStateInitialImplCopyWith<$Res> {
  __$$AddRefImageStateInitialImplCopyWithImpl(
      _$AddRefImageStateInitialImpl _value,
      $Res Function(_$AddRefImageStateInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AddRefImageStateInitialImpl
    with DiagnosticableTreeMixin
    implements AddRefImageStateInitial {
  const _$AddRefImageStateInitialImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'AddRefImageState.initial'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class AddRefImageStateInitial implements AddRefImageState {
  const factory AddRefImageStateInitial() = _$AddRefImageStateInitialImpl;
}

/// @nodoc
abstract class _$$AddRefImageStateAddingImageImplCopyWith<$Res> {
  factory _$$AddRefImageStateAddingImageImplCopyWith(
          _$AddRefImageStateAddingImageImpl value,
          $Res Function(_$AddRefImageStateAddingImageImpl) then) =
      __$$AddRefImageStateAddingImageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddRefImageStateAddingImageImplCopyWithImpl<$Res>
    extends _$AddRefImageStateCopyWithImpl<$Res,
        _$AddRefImageStateAddingImageImpl>
    implements _$$AddRefImageStateAddingImageImplCopyWith<$Res> {
  __$$AddRefImageStateAddingImageImplCopyWithImpl(
      _$AddRefImageStateAddingImageImpl _value,
      $Res Function(_$AddRefImageStateAddingImageImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AddRefImageStateAddingImageImpl
    with DiagnosticableTreeMixin
    implements AddRefImageStateAddingImage {
  const _$AddRefImageStateAddingImageImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageState.addingImages()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'AddRefImageState.addingImages'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageStateAddingImageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class AddRefImageStateAddingImage implements AddRefImageState {
  const factory AddRefImageStateAddingImage() =
      _$AddRefImageStateAddingImageImpl;
}

/// @nodoc
abstract class _$$AddRefImageStateImagesAddedImplCopyWith<$Res> {
  factory _$$AddRefImageStateImagesAddedImplCopyWith(
          _$AddRefImageStateImagesAddedImpl value,
          $Res Function(_$AddRefImageStateImagesAddedImpl) then) =
      __$$AddRefImageStateImagesAddedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AddRefImageResult result});

  $AddRefImageResultCopyWith<$Res> get result;
}

/// @nodoc
class __$$AddRefImageStateImagesAddedImplCopyWithImpl<$Res>
    extends _$AddRefImageStateCopyWithImpl<$Res,
        _$AddRefImageStateImagesAddedImpl>
    implements _$$AddRefImageStateImagesAddedImplCopyWith<$Res> {
  __$$AddRefImageStateImagesAddedImplCopyWithImpl(
      _$AddRefImageStateImagesAddedImpl _value,
      $Res Function(_$AddRefImageStateImagesAddedImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$AddRefImageStateImagesAddedImpl(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as AddRefImageResult,
    ));
  }

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AddRefImageResultCopyWith<$Res> get result {
    return $AddRefImageResultCopyWith<$Res>(_value.result, (value) {
      return _then(_value.copyWith(result: value));
    });
  }
}

/// @nodoc

class _$AddRefImageStateImagesAddedImpl
    with DiagnosticableTreeMixin
    implements AddRefImageStateImagesAdded {
  const _$AddRefImageStateImagesAddedImpl(this.result);

  @override
  final AddRefImageResult result;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageState.imagesAdded(result: $result)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddRefImageState.imagesAdded'))
      ..add(DiagnosticsProperty('result', result));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageStateImagesAddedImpl &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddRefImageStateImagesAddedImplCopyWith<_$AddRefImageStateImagesAddedImpl>
      get copyWith => __$$AddRefImageStateImagesAddedImplCopyWithImpl<
          _$AddRefImageStateImagesAddedImpl>(this, _$identity);
}

abstract class AddRefImageStateImagesAdded implements AddRefImageState {
  const factory AddRefImageStateImagesAdded(final AddRefImageResult result) =
      _$AddRefImageStateImagesAddedImpl;

  AddRefImageResult get result;

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddRefImageStateImagesAddedImplCopyWith<_$AddRefImageStateImagesAddedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddRefImageStateNoSecureKeyImplCopyWith<$Res> {
  factory _$$AddRefImageStateNoSecureKeyImplCopyWith(
          _$AddRefImageStateNoSecureKeyImpl value,
          $Res Function(_$AddRefImageStateNoSecureKeyImpl) then) =
      __$$AddRefImageStateNoSecureKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddRefImageStateNoSecureKeyImplCopyWithImpl<$Res>
    extends _$AddRefImageStateCopyWithImpl<$Res,
        _$AddRefImageStateNoSecureKeyImpl>
    implements _$$AddRefImageStateNoSecureKeyImplCopyWith<$Res> {
  __$$AddRefImageStateNoSecureKeyImplCopyWithImpl(
      _$AddRefImageStateNoSecureKeyImpl _value,
      $Res Function(_$AddRefImageStateNoSecureKeyImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AddRefImageStateNoSecureKeyImpl
    with DiagnosticableTreeMixin
    implements AddRefImageStateNoSecureKey {
  const _$AddRefImageStateNoSecureKeyImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageState.noSecureKey()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'AddRefImageState.noSecureKey'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageStateNoSecureKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class AddRefImageStateNoSecureKey implements AddRefImageState {
  const factory AddRefImageStateNoSecureKey() =
      _$AddRefImageStateNoSecureKeyImpl;
}

/// @nodoc
mixin _$AddRefImageResult {
  List<RefImageInfo> get successList => throw _privateConstructorUsedError;
  List<AddRefImageError> get failedList => throw _privateConstructorUsedError;

  /// Create a copy of AddRefImageResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AddRefImageResultCopyWith<AddRefImageResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddRefImageResultCopyWith<$Res> {
  factory $AddRefImageResultCopyWith(
          AddRefImageResult value, $Res Function(AddRefImageResult) then) =
      _$AddRefImageResultCopyWithImpl<$Res, AddRefImageResult>;
  @useResult
  $Res call(
      {List<RefImageInfo> successList, List<AddRefImageError> failedList});
}

/// @nodoc
class _$AddRefImageResultCopyWithImpl<$Res, $Val extends AddRefImageResult>
    implements $AddRefImageResultCopyWith<$Res> {
  _$AddRefImageResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddRefImageResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? successList = null,
    Object? failedList = null,
  }) {
    return _then(_value.copyWith(
      successList: null == successList
          ? _value.successList
          : successList // ignore: cast_nullable_to_non_nullable
              as List<RefImageInfo>,
      failedList: null == failedList
          ? _value.failedList
          : failedList // ignore: cast_nullable_to_non_nullable
              as List<AddRefImageError>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AddRefImageResultImplCopyWith<$Res>
    implements $AddRefImageResultCopyWith<$Res> {
  factory _$$AddRefImageResultImplCopyWith(_$AddRefImageResultImpl value,
          $Res Function(_$AddRefImageResultImpl) then) =
      __$$AddRefImageResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<RefImageInfo> successList, List<AddRefImageError> failedList});
}

/// @nodoc
class __$$AddRefImageResultImplCopyWithImpl<$Res>
    extends _$AddRefImageResultCopyWithImpl<$Res, _$AddRefImageResultImpl>
    implements _$$AddRefImageResultImplCopyWith<$Res> {
  __$$AddRefImageResultImplCopyWithImpl(_$AddRefImageResultImpl _value,
      $Res Function(_$AddRefImageResultImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? successList = null,
    Object? failedList = null,
  }) {
    return _then(_$AddRefImageResultImpl(
      successList: null == successList
          ? _value._successList
          : successList // ignore: cast_nullable_to_non_nullable
              as List<RefImageInfo>,
      failedList: null == failedList
          ? _value._failedList
          : failedList // ignore: cast_nullable_to_non_nullable
              as List<AddRefImageError>,
    ));
  }
}

/// @nodoc

class _$AddRefImageResultImpl
    with DiagnosticableTreeMixin
    implements _AddRefImageResult {
  const _$AddRefImageResultImpl(
      {required final List<RefImageInfo> successList,
      required final List<AddRefImageError> failedList})
      : _successList = successList,
        _failedList = failedList;

  final List<RefImageInfo> _successList;
  @override
  List<RefImageInfo> get successList {
    if (_successList is EqualUnmodifiableListView) return _successList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_successList);
  }

  final List<AddRefImageError> _failedList;
  @override
  List<AddRefImageError> get failedList {
    if (_failedList is EqualUnmodifiableListView) return _failedList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_failedList);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageResult(successList: $successList, failedList: $failedList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddRefImageResult'))
      ..add(DiagnosticsProperty('successList', successList))
      ..add(DiagnosticsProperty('failedList', failedList));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageResultImpl &&
            const DeepCollectionEquality()
                .equals(other._successList, _successList) &&
            const DeepCollectionEquality()
                .equals(other._failedList, _failedList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_successList),
      const DeepCollectionEquality().hash(_failedList));

  /// Create a copy of AddRefImageResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddRefImageResultImplCopyWith<_$AddRefImageResultImpl> get copyWith =>
      __$$AddRefImageResultImplCopyWithImpl<_$AddRefImageResultImpl>(
          this, _$identity);
}

abstract class _AddRefImageResult implements AddRefImageResult {
  const factory _AddRefImageResult(
          {required final List<RefImageInfo> successList,
          required final List<AddRefImageError> failedList}) =
      _$AddRefImageResultImpl;

  @override
  List<RefImageInfo> get successList;
  @override
  List<AddRefImageError> get failedList;

  /// Create a copy of AddRefImageResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddRefImageResultImplCopyWith<_$AddRefImageResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddRefImageError {}

/// @nodoc
abstract class $AddRefImageErrorCopyWith<$Res> {
  factory $AddRefImageErrorCopyWith(
          AddRefImageError value, $Res Function(AddRefImageError) then) =
      _$AddRefImageErrorCopyWithImpl<$Res, AddRefImageError>;
}

/// @nodoc
class _$AddRefImageErrorCopyWithImpl<$Res, $Val extends AddRefImageError>
    implements $AddRefImageErrorCopyWith<$Res> {
  _$AddRefImageErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AddRefImageErrorDataImplCopyWith<$Res> {
  factory _$$AddRefImageErrorDataImplCopyWith(_$AddRefImageErrorDataImpl value,
          $Res Function(_$AddRefImageErrorDataImpl) then) =
      __$$AddRefImageErrorDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String path, Exception? exception, StackTrace? stackTrace});
}

/// @nodoc
class __$$AddRefImageErrorDataImplCopyWithImpl<$Res>
    extends _$AddRefImageErrorCopyWithImpl<$Res, _$AddRefImageErrorDataImpl>
    implements _$$AddRefImageErrorDataImplCopyWith<$Res> {
  __$$AddRefImageErrorDataImplCopyWithImpl(_$AddRefImageErrorDataImpl _value,
      $Res Function(_$AddRefImageErrorDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? exception = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$AddRefImageErrorDataImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      exception: freezed == exception
          ? _value.exception
          : exception // ignore: cast_nullable_to_non_nullable
              as Exception?,
      stackTrace: freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$AddRefImageErrorDataImpl
    with DiagnosticableTreeMixin
    implements AddRefImageErrorData {
  const _$AddRefImageErrorDataImpl(
      {required this.path, this.exception, this.stackTrace});

  @override
  final String path;
  @override
  final Exception? exception;
  @override
  final StackTrace? stackTrace;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageError(path: $path, exception: $exception, stackTrace: $stackTrace)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddRefImageError'))
      ..add(DiagnosticsProperty('path', path))
      ..add(DiagnosticsProperty('exception', exception))
      ..add(DiagnosticsProperty('stackTrace', stackTrace));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageErrorDataImpl &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.exception, exception) ||
                other.exception == exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path, exception, stackTrace);

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddRefImageErrorDataImplCopyWith<_$AddRefImageErrorDataImpl>
      get copyWith =>
          __$$AddRefImageErrorDataImplCopyWithImpl<_$AddRefImageErrorDataImpl>(
              this, _$identity);
}

abstract class AddRefImageErrorData implements AddRefImageError {
  const factory AddRefImageErrorData(
      {required final String path,
      final Exception? exception,
      final StackTrace? stackTrace}) = _$AddRefImageErrorDataImpl;

  String get path;
  Exception? get exception;
  StackTrace? get stackTrace;

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddRefImageErrorDataImplCopyWith<_$AddRefImageErrorDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddRefImageErrorFsImplCopyWith<$Res> {
  factory _$$AddRefImageErrorFsImplCopyWith(_$AddRefImageErrorFsImpl value,
          $Res Function(_$AddRefImageErrorFsImpl) then) =
      __$$AddRefImageErrorFsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String path, FsError error});

  $FsErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$AddRefImageErrorFsImplCopyWithImpl<$Res>
    extends _$AddRefImageErrorCopyWithImpl<$Res, _$AddRefImageErrorFsImpl>
    implements _$$AddRefImageErrorFsImplCopyWith<$Res> {
  __$$AddRefImageErrorFsImplCopyWithImpl(_$AddRefImageErrorFsImpl _value,
      $Res Function(_$AddRefImageErrorFsImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? error = null,
  }) {
    return _then(_$AddRefImageErrorFsImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FsError,
    ));
  }

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FsErrorCopyWith<$Res> get error {
    return $FsErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$AddRefImageErrorFsImpl
    with DiagnosticableTreeMixin
    implements AddRefImageErrorFs {
  const _$AddRefImageErrorFsImpl({required this.path, required this.error});

  @override
  final String path;
  @override
  final FsError error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageError.fs(path: $path, error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddRefImageError.fs'))
      ..add(DiagnosticsProperty('path', path))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageErrorFsImpl &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path, error);

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddRefImageErrorFsImplCopyWith<_$AddRefImageErrorFsImpl> get copyWith =>
      __$$AddRefImageErrorFsImplCopyWithImpl<_$AddRefImageErrorFsImpl>(
          this, _$identity);
}

abstract class AddRefImageErrorFs implements AddRefImageError {
  const factory AddRefImageErrorFs(
      {required final String path,
      required final FsError error}) = _$AddRefImageErrorFsImpl;

  String get path;
  FsError get error;

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddRefImageErrorFsImplCopyWith<_$AddRefImageErrorFsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddRefImageErrorEncryptImplCopyWith<$Res> {
  factory _$$AddRefImageErrorEncryptImplCopyWith(
          _$AddRefImageErrorEncryptImpl value,
          $Res Function(_$AddRefImageErrorEncryptImpl) then) =
      __$$AddRefImageErrorEncryptImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String path, EncryptError error});

  $EncryptErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$AddRefImageErrorEncryptImplCopyWithImpl<$Res>
    extends _$AddRefImageErrorCopyWithImpl<$Res, _$AddRefImageErrorEncryptImpl>
    implements _$$AddRefImageErrorEncryptImplCopyWith<$Res> {
  __$$AddRefImageErrorEncryptImplCopyWithImpl(
      _$AddRefImageErrorEncryptImpl _value,
      $Res Function(_$AddRefImageErrorEncryptImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? error = null,
  }) {
    return _then(_$AddRefImageErrorEncryptImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as EncryptError,
    ));
  }

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EncryptErrorCopyWith<$Res> get error {
    return $EncryptErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$AddRefImageErrorEncryptImpl
    with DiagnosticableTreeMixin
    implements AddRefImageErrorEncrypt {
  const _$AddRefImageErrorEncryptImpl(
      {required this.path, required this.error});

  @override
  final String path;
  @override
  final EncryptError error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageError.encrypt(path: $path, error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddRefImageError.encrypt'))
      ..add(DiagnosticsProperty('path', path))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageErrorEncryptImpl &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path, error);

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddRefImageErrorEncryptImplCopyWith<_$AddRefImageErrorEncryptImpl>
      get copyWith => __$$AddRefImageErrorEncryptImplCopyWithImpl<
          _$AddRefImageErrorEncryptImpl>(this, _$identity);
}

abstract class AddRefImageErrorEncrypt implements AddRefImageError {
  const factory AddRefImageErrorEncrypt(
      {required final String path,
      required final EncryptError error}) = _$AddRefImageErrorEncryptImpl;

  String get path;
  EncryptError get error;

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddRefImageErrorEncryptImplCopyWith<_$AddRefImageErrorEncryptImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddRefImageErrorNoSecureKeyImplCopyWith<$Res> {
  factory _$$AddRefImageErrorNoSecureKeyImplCopyWith(
          _$AddRefImageErrorNoSecureKeyImpl value,
          $Res Function(_$AddRefImageErrorNoSecureKeyImpl) then) =
      __$$AddRefImageErrorNoSecureKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddRefImageErrorNoSecureKeyImplCopyWithImpl<$Res>
    extends _$AddRefImageErrorCopyWithImpl<$Res,
        _$AddRefImageErrorNoSecureKeyImpl>
    implements _$$AddRefImageErrorNoSecureKeyImplCopyWith<$Res> {
  __$$AddRefImageErrorNoSecureKeyImplCopyWithImpl(
      _$AddRefImageErrorNoSecureKeyImpl _value,
      $Res Function(_$AddRefImageErrorNoSecureKeyImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddRefImageError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AddRefImageErrorNoSecureKeyImpl
    with DiagnosticableTreeMixin
    implements AddRefImageErrorNoSecureKey {
  const _$AddRefImageErrorNoSecureKeyImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddRefImageError.noSecureKey()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'AddRefImageError.noSecureKey'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddRefImageErrorNoSecureKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class AddRefImageErrorNoSecureKey implements AddRefImageError {
  const factory AddRefImageErrorNoSecureKey() =
      _$AddRefImageErrorNoSecureKeyImpl;
}
